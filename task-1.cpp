#include <iostream>     // Підключення стандартної бібліотеки вводу/виводу.
// Забезпечує доступ до об'єкта std::cout, який дозволяє виводити інформацію на екран.
#include <cstdlib>      // Підключення бібліотеки для роботи з функцією rand() – генератором випадкових чисел.
#include <ctime>        // Підключення бібліотеки, яка надає доступ до функції time() для ініціалізації генератора.
using namespace std;    // Дозволяє використовувати елементи стандартної бібліотеки без явного зазначення простору імен std::

int main() {
    // ============================================
    // 1. Визначення розміру динамічного масиву
    // ============================================
    // У цьому прикладі ми вибираємо масив з 10 елементів.
    int size = 10;  

    // ============================================
    // 2. Виділення динамічної пам’яті за допомогою оператора new
    // ============================================
    // Оператор new виділяє блок пам'яті в купі (heap) для масиву з "size" елементів типу float.
    // new float[size] повертає вказівник на перший елемент виділеного блоку.
    float* arr = new float[size];
    // На рівні апаратного забезпечення: системі оперативної пам’яті резервується послідовний блок розміром size * sizeof(float) байтів.
    // Змінна "arr" містить адресу першого байта цього блоку, що дозволяє звертатися до всіх елементів через арифметику вказівників.

    // ============================================
    // 3. Ініціалізація генератора випадкових чисел
    // ============================================
    // Функція time(NULL) повертає поточний час (типу time_t), який використовується як seed (початкове значення) для генератора випадкових чисел.
    // Це дозволяє отримувати різні послідовності чисел при кожному запуску програми.
    srand(static_cast<unsigned>(time(NULL)));

    // ============================================
    // 4. Заповнення масиву випадковими значеннями з діапазону (-2, 2)
    // ============================================
    // Щоб заповнити масив без використання індексації, використовуємо арифметику вказівників.
    // Оголошуємо вказівник p, який спочатку вказує на початок масиву (тобто, на адресу першого елемента).
    float* p = arr;
    // Обчислюємо кінцеву адресу, яка знаходиться одразу після останнього елемента масиву.
    // Арифметика вказівників дозволяє виконати операцію p + size, що означає зсув на size елементів типу float.
    float* end = arr + size;
    
    // Цикл while обходить всі елементи масиву, поки вказівник p не досягне адреси end.
    while (p < end) {
        // Розіменування вказівника *p дає доступ до значення за адресою, яку містить p.
        // Вираз static_cast<float>(rand()) / static_cast<float>(RAND_MAX) генерує число в діапазоні [0, 1].
        // Множення на 4.0f розширює діапазон до [0, 4], а віднімання 2.0f зсуває його до [-2, 2].
        *p = -2.0f + (static_cast<float>(rand()) / static_cast<float>(RAND_MAX)) * 4.0f;
        // На машинному рівні: процесор обчислює нове значення, яке записується в пам'ять за адресою, що міститься у p.
        
        // Оператор p++ збільшує адресу, що міститься у вказівнику, на розмір одного елемента типу float (наприклад, 4 байти),
        // що дозволяє перейти до наступного елемента в масиві.
        p++;
    }
    
    // ============================================
    // 5. Підрахунок кількості додатних та від'ємних чисел
    // ============================================
    // Після заповнення масиву повертаємо вказівник p до початку масиву, щоб повторно пройти по всіх елементах.
    p = arr;
    
    // Ініціалізуємо змінні для підрахунку кількості додатних і від'ємних чисел.
    int positiveCount = 0;
    int negativeCount = 0;
    
    // За допомогою циклу while проходимо по всіх елементах масиву.
    while (p < end) {
        // Розіменування *p дозволяє отримати значення поточного елемента.
        // Якщо значення більше нуля, збільшуємо лічильник додатних чисел.
        if (*p > 0.0f) {
            positiveCount++;
        } 
        // Якщо значення менше нуля, збільшуємо лічильник від'ємних чисел.
        else if (*p < 0.0f) {
            negativeCount++;
        }
        // Якщо значення рівне нулю, воно не враховується згідно з умовою задачі.
        
        // Переходимо до наступного елемента за допомогою p++.
        p++;
    }
    
    // ============================================
    // 6. Вивід результатів
    // ============================================
    // Використовуючи std::cout, виводимо кількість додатних та від'ємних чисел.
    cout << "Кількість додатних чисел: " << positiveCount << endl;
    cout << "Кількість від'ємних чисел: " << negativeCount << endl;
    
    // ============================================
    // 7. Звільнення динамічно виділеної пам’яті
    // ============================================
    // Після завершення роботи з масивом обов'язково звільняємо пам'ять, виділену за допомогою оператора new.
    // Оператор delete[] повертає пам'ять операційній системі, запобігаючи витоку пам’яті.
    delete [] arr;
    
    // Завершення роботи програми. Повернення 0 означає успішне виконання.
    return 0;
}
